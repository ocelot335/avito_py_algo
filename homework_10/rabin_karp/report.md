использованный алгоритм соответсвует описанию из википедии:
https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A0%D0%B0%D0%B1%D0%B8%D0%BD%D0%B0_%E2%80%94_%D0%9A%D0%B0%D1%80%D0%BF%D0%B0

Более конкретно, использована схема из (Dietzfelbinger, Gil, Matias, Pippinger, 1992.)

Единственно, что при убирании символа из окна, я сначала умножаю весь текущий хэш окна на x, а затем вычитаю hash_window -= (ord(s[idx - m]) * x_m) % q. Обычно, сначала вычитают, потом умножают, но я решил сделать по другому.

Ориентируясь на вычисления вероятности коллизий в схеме Дитзфелбингера(см. Википедию или соответсвующую статью, хотя достаточно вспомнить теорему Безу для многочленов над полями), найдём асимптотическую оценку матожидания сложности.
Во-первых, существует часть соответсвующая проходу по s, которая составляет O(n).
Во-вторых, количество проверок пропорционально реальному количеству вхождений, то есть вклад равен O(m*(#количество вхождений))
В-третьих, учтём проверки происходящие из-за колизий хэша. Вероятность такой коллизии для двух неравных строк равна примеро m/q, тогда матожидание коллизий равно m*(n-m)/q, тогда коллизии вносят вклад O(m*m*(n-m)/q) = O(m**2*n/q)

Тогда матожидание сложности имеет асимптотику O(n+m*(#количество вхождений)+m**2*n/q)